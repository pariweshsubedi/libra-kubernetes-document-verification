// account: bbchain, 1000000
// account: alice, 1000000
// account: bob, 1000000

// sender: bbchain
module Course {
    import 0x0.LibraAccount;
    import 0x0.LibraCoin;
    import 0x0.Vector;

    struct Student {
      student_address: address
    }

    resource T {
        someBoolean: bool,
        enrolledStudents: Vector.T<Self.Student>,

        // events
        student_added_events: LibraAccount.EventHandle<Self.StudentAddedEvent>
    }

    // Message Student Added Event
    struct StudentAddedEvent {
        // Address of the Student added
        student: address,
        // Address of the requester who wants to add student
        requester: address,
    }

    // Adds Student as enrolled students
    public add_student(student: address) acquires T {
        Self.add_student_with_event(move(student), get_txn_sender());
        return;
    }

    public add_student_with_event(
        student_address: address,
        requester_address: address
    ) acquires T {
        let requester_account_ref: &mut Self.T;
        let new_student: Self.Student;
        
        // Verify that the student account exists
        assert(LibraAccount.exists(copy(student_address)), 5);

        // create new student using Student struct
        new_student = Student { student_address: copy(student_address)};
        
        // get the requestor's resource to add students in it
        requester_account_ref = borrow_global_mut<T>(copy(requester_address));        

        // set some value in the variable
        // *(&mut move(requester_account_ref).someBoolean) = false;
        
        //add elements to vector
        Vector.push_back<Self.Student>(&mut copy(requester_account_ref).enrolledStudents, move(new_student));

        // release event after student addition
        LibraAccount.emit_event<Self.StudentAddedEvent>(
            &mut copy(requester_account_ref).student_added_events,
            StudentAddedEvent {
                student: move(student_address),
                requester: move(requester_address)
            },
        );

        return ;
    }

    // Returns number of enrolled student in a course
    public get_enrolled_count(course_address: address) :u64 acquires T{
        let course: &mut Self.T;
        let total_enrolled: u64;
        course = borrow_global_mut<T>(copy(course_address));
        total_enrolled = Vector.length<Self.Student>(&copy(course).enrolledStudents);
        return move(total_enrolled);
    }

}