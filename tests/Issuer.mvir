//! account: bbchain, 1000000
//! account: mathcourse, 1000000
//! account: mathprofessor, 1000000
//! account: mathevaluator, 1000000
//! account: student1, 1000000

//! new-transaction
//! sender: bbchain
// The Issuer module is more like a ERC20 standard that has to be followed 
// to create a coin in the ethereum system but here it will be used for
// creating notary module and can be used by courses in the libra network.
module Issuer {
    import 0x0.LibraAccount;
    import 0x0.Vector;
    // import {{bbchain}}.OwnerGroup;
    // import 0x0.LibraSystem;
    
    // LibraSystem.get_current_block_height()
    // LibraSystem.get_current_block_id()
    // LibraSystem.get_current_timestamp()
    // LibraSystem.get_current_proposer()

    struct Signature{
        owner: address,
        signed_digest: bytearray,
        // TODO
        // replace owner address with PK
    }

    // map unique counter to issued address
    // counter only increases
    struct Nonce{
        counter: u64,
        issued_to: address
    }

    // subject and list of digest in the subject
    struct DigestByCourse{
        digest: Vector.T<bytearray>,
        course: address
    }

    // Events
    // Message Student Added Event
    struct StudentAddedEvent {
        // Address of the Student added
        student: address,
        // Address of the requester who wants to add student
        requester: address,
    }

    // Signed Credential Event
    struct CredentialSigned {
        student: address,
        digest: bytearray,
        signedBlock: u64
    }

    // Holds information so that issuer can verify 
    // credibility of the child nodes
    resource IssuerResource{
        issued_to: Vector.T<address>, // vector of addresses where the credential has been provided
        revoked_from: Vector.T<address>, // vector of addresses where the credential has been revoked
        credentials : Vector.T<Self.CredentialProof>,
        revocations : Vector.T<Self.RevocationProof>,
        digests: Vector.T<Self.DigestByCourse>,
        nonce: Self.Nonce
    }

    resource Events{
        credential_signed: LibraAccount.EventHandle<Self.CredentialSigned>
    }

    // // will be stored with the subject
    resource CredentialProof {
        quorom: u64, // number of signatures that prove it as signed
        owners: Vector.T<address>,
        nonce: u64,
        signatures: Vector.T<Self.Signature>, // pks that signed the credential proof
        signed: bool, // if all involved parties signed
        digest: bytearray,
        revoked: bool
    }

    // will be stored with the subject
    resource RevocationProof {
        credentialProof: Self.CredentialProof,
        reason: bytearray
    }

    // // Checks if the credential was revoked based on it's digest
    // public getIsRevoked(credential_proof: &Self.CredentialProof) :bool{
    //     return *& move(credential_proof).revoked;
    // }

    // Verify if a given credential (i.e. represented by it's digest) corresponds to the aggregation of all stored credentials of a particular subject
    // public verifyCredential(digest: bytearray) acquires CredentialProof{
        
    //     // get credential associated with digest
    //     let credential_proof Self.CredentialProof;
    //     credential_proof = Self.getCredentialProofByDigest(move(digest));

        
    //     assert(*& move(credential_proof).revoked == false);

    //    // Emit Event

    //     return;
    // }

    // // Revokes a credential for a given reason based on it's digest
    // public revokeCredential() acquires CredentialProof{
    //     return;
    // }

    // // Confirms the agreement about the credential between the subject and the issuer
    // public confirmCredential() acquires CredentialProof{
    //     return;
    // }

    // issue credential: Registers the creation of a credential for a particular subject
    // public registerCredential() acquires CredentialProof{
         
    //     return;
    // }


    // Internal Methods
    // getCredentialProofByDigest(digest: bytearray) :Self.CredentialProof{
    //     let credential_proof Self.CredentialProof;

    //     // TODO : get credential proof by digest

    //     return move(credential_proof);
    // }

}