//! account: bbchain, 1000000
//! account: mathcourse, 1000000
//! account: mathprofessor, 1000000
//! account: mathevaluator, 1000000
//! account: student1, 1000000

//! new-transaction
//! sender: bbchain
// The Issuer module is more like a ERC20 standard that has to be followed 
// to create a coin in the ethereum system but here it will be used for
// creating notary module and can be used by courses in the libra network.
module Issuer {
    import 0x0.LibraAccount;
    import 0x0.Vector;
    // import {{bbchain}}.OwnerGroup;
    // import 0x0.LibraSystem;
    
    // LibraSystem.get_current_block_height()
    // LibraSystem.get_current_block_id()
    // LibraSystem.get_current_timestamp()
    // LibraSystem.get_current_proposer()

    //--------------------------------
    // Structs
    //--------------------------------

    struct Signature{
        owner: address,
        // TODO
        // replace owner address with PK
    }

    // Signed Credential Event
    struct CredentialSigned {
        student: address,
        digest: bytearray,
        signedBlock: u64
    }

    //--------------------------------
    // Events
    //--------------------------------
    
    // Message Student Added Event
    struct StudentAddedEvent {
        // Address of the Student added
        student: address,
        // Address of the requester who wants to add student
        requester: address,
    }

    //--------------------------------
    // Resources
    //--------------------------------

    // Holds information so that issuer can verify 
    // credibility of the child nodes
    resource IssuerResource{
        quorom: u64, // number of signatures that prove it as signed
        owners: Vector.T<address>,
        subjects : Vector.T<address>, // stores all address that the Issuer has interacted with
        digests : Vector.T<bytearray>, // stores all signed digest
        revoked_digests : Vector.T<bytearray>, // stores all revoked digests
        nonce: u64,
        credential_proofs: Vector.T<Self.CredentialProof>
    }

    resource Events{
        credential_signed: LibraAccount.EventHandle<Self.CredentialSigned>
    }

    // will be stored with the subject(student)
    resource CredentialProof {
        owner_signatures: Vector.T<Self.Signature>, // owners that signed the credential proof
        signed: bool, // if all involved parties signed
        digest: bytearray,
        revoked: bool,
        nonce: u64, // counter from issuer
        subject: address,
    }

    // will be stored with the subject(student)
    resource RevocationProof {
        credentialProof: Self.CredentialProof,
        reason: bytearray,
        nonce: u64 // counter from issuer
    }

    //--------------------------------
    // Methods
    //--------------------------------

    // issue credential : Registers the creation of a credential for a particular subject
    // invoker : course
    public registerCredential(subject: address, digest: bytearray) acquires IssuerResource {
        let sender_address: address;
        let requester_issuer_res_ref: &mut Self.IssuerResource;
        let new_credential_proof: Self.CredentialProof;
        let new_nonce: u64;

        sender_address = get_txn_sender();

        // Issuer shouldn't hold any credential or revocation proofs
        assert(!exists<CredentialProof>(copy(sender_address)), 3);
        assert(!exists<RevocationProof>(copy(sender_address)), 3);

        requester_issuer_res_ref = borrow_global_mut<IssuerResource>(copy(sender_address));

        // verify that the credential with provided digest hasnt been revoked and hasnt already been registered
        assert(!Vector.contains<bytearray>(&copy(requester_issuer_res_ref).revoked_digests, &digest), 1);
        assert(!Vector.contains<bytearray>(&copy(requester_issuer_res_ref).digests, &digest), 1);

        // Increment Nonce on Issuer
        new_nonce = *&copy(requester_issuer_res_ref).nonce + 1;
        *&mut copy(requester_issuer_res_ref).nonce = copy(new_nonce);

        // Issuing Credential
        // Two ways to handle this
        // 1) credential wallet is already created for a student and move the credential proof to the wallet. 
        // 2) store credential proof with issuer and move it to student after the student signs the credential proof

        // Implementation 2:
        // add new credential proof to Issuer resource
        Vector.push_back<Self.CredentialProof>(
            &mut copy(requester_issuer_res_ref).credential_proofs, 
            Self.createCredentialProof(move(subject), move(digest), move(new_nonce))
        );

        // Emit Event
        return;
    }


    //--------------------------------
    // Internal Methods
    //--------------------------------

    // Creates clean credential proof
    createCredentialProof(subject: address, digest: bytearray, nonce: u64): Self.CredentialProof{
        return CredentialProof {
            owner_signatures: Vector.empty<Self.Signature>(),
            signed: false,
            digest: move(digest),
            revoked: false,
            nonce: move(nonce),
            subject: move(subject)
        };
    }
    

}