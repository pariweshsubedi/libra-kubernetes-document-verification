//! account: bbchain, 1000000
//! account: university, 1000000
//! account: mathcourse, 1000000
//! account: mathprofessor, 1000000
//! account: mathevaluator, 1000000
//! account: student1, 1000000

//! new-transaction
//! sender: bbchain
module Proofs {
    import 0x0.Vector;

    struct Credential{
        digest : bytearray,
        holder : address,
        signed : bool,
        revoked : bool,
        time: u64,
        owners_signed : Vector.T<address>,
        owners : Vector.T<address>
    }

    resource CredentialProof{
        quorum: u64,
        holder: address,
        issuer: address,
        owners : Vector.T<address>,
        valid : bool, // signed by quorum of owners
        revoked : bool,
        digest : bytearray,
        credentials: Vector.T<Self.Credential>,
        required_credentials: u64 // sign only if expected number of credentials is reached
    }

    resource RevocationProof {
        credentialProof: Self.CredentialProof,
        reason: bytearray,
        nonce: u64 // counter from issuer
    }

    // stored with holder
    resource CredentialAccount{
        wallet_issuer : address,
        holder : address,
        credential_proofs : Vector.T<Self.CredentialProof>   
    }

    // stored with issuer
    resource RevocationProofs{
        credential_proofs : Vector.T<Self.RevocationProof>   
    }

    public moveCredentialsProofToAccount(credential_proof: Self.CredentialProof, account: address) acquires CredentialAccount{
        let credential_account_ref: &mut Self.CredentialAccount;
    
        // assert(&copy(credential_proof).holder == copy(account), 2);
        
        credential_account_ref = borrow_global_mut<CredentialAccount>(copy(account));
        Vector.push_back<Self.CredentialProof>(
            &mut copy(credential_account_ref).credential_proofs, 
            move(credential_proof)
        );
        return;
    }

    public getCredentialByDigest(credentials: &Vector.T<Self.Credential>, digest: &bytearray): u64 * bool{
        let len: u64;
        let i: u64;
        let credential_ref: &Self.Credential;

        i = 0;
        len = Vector.length<Self.Credential>(copy(credentials));

        while (copy(i) < copy(len)) {
            credential_ref = Vector.borrow<Self.Credential>(copy(credentials), copy(i));
            
            if (*copy(digest) == *&copy(credential_ref).digest) {
                return copy(i), true;
            }
            i = move(i) + 1;
        }

        return 0, false;
    }

    public getCredentialProofIndexByDigest(credential_proofs: &Vector.T<Self.CredentialProof>, digest: &bytearray, check_valid: bool): u64 * bool {
        let len: u64;
        let i: u64;
        let credential_proof_ref: &Self.CredentialProof;

        i = 0;
        len = Vector.length<Self.CredentialProof>(copy(credential_proofs));

        while (copy(i) < copy(len)) {
            credential_proof_ref = Vector.borrow<Self.CredentialProof>(copy(credential_proofs), copy(i));
            
            if (*copy(digest) == *&copy(credential_proof_ref).digest) {
                if(copy(check_valid)){
                    if(*&copy(credential_proof_ref).valid){
                        return copy(i), true;
                    }
                }else{
                    return copy(i), true;
                }
            }
            i = move(i) + 1;
        }

        return 0, false;
    }

    public insertCredential(credential_proofs_mut: &mut Vector.T<Self.CredentialProof>, credential_proofs: &Vector.T<Self.CredentialProof>, _credential: Self.Credential): bool{
        let len: u64;
        let i: u64;
        let credential_proof_ref: &mut Self.CredentialProof;
        let _holder: address;

        _holder = 0x00; //todo: Self.getCredentialHolder(&_credential);

        i = 0;
        len = Vector.length<Self.CredentialProof>(copy(credential_proofs));
        while (copy(i) < copy(len)) {
            credential_proof_ref = Vector.borrow_mut<Self.CredentialProof>(copy(credential_proofs_mut), copy(i));
            // if (copy(addr) == 0x00) {
            //     return;
            // }
            if (copy(_holder) == *&copy(credential_proof_ref).holder) {
                Vector.push_back<Self.Credential>(
                    &mut move(credential_proof_ref).credentials, 
                    move(_credential)
                );
                return true;
            }
            i = move(i) + 1;
        }

        return false;
    }

    public hasCredentialAccount(addr: address): bool {
        let has: bool;
        has = exists<CredentialAccount>(move(addr));
        return move(has);
    }

    public newCredential(holder: address, digest: bytearray, _owners: Vector.T<address>,): Self.Credential{
        return Credential{
            digest : copy(digest),
            holder : copy(holder),
            signed : false,
            revoked : false,
            time: 1, // replace this with time.now() from newer libra version
            owners_signed : Vector.empty<address>(),
            owners : move(_owners)
        };
    }

    public newCredentialAccount(_issuer: address, _holder: address){
        move_to_sender<CredentialAccount>(
            CredentialAccount {
                wallet_issuer : move(_issuer),
                holder : move(_holder),
                credential_proofs : Vector.empty<Self.CredentialProof>()
            }
        );
        return;
    }

    public newCredentialProof(_issuer: address, _holder: address, _quorum: u64, _owners: Vector.T<address>, _required_credentials: u64): Self.CredentialProof {
        return CredentialProof{
            quorum : move(_quorum),
            holder : move(_holder),
            issuer : move(_issuer),
            owners : move(_owners),
            valid : false, 
            revoked : false,
            digest : h"",
            credentials : Vector.empty<Self.Credential>(),
            required_credentials : move(_required_credentials)
        };      
    }
}


// module that allows issuer to mark a credential resource for recepients
//! new-transaction
//! sender: bbchain
module EarmarkedProofs {
    import {{bbchain}}.Proofs;
    import 0x0.Vector;

    struct DigestHolder {
        issuer : Vector.T<address>,
        owners : Vector.T<address>,
        digest : bytearray,
        holder : address
    }

    //--------------------------------
    // Resources
    //--------------------------------

    // A wrapper containing a Libra coin and the address of the recipient the
    // coin is earmarked for.
    resource LoggedProofs {
        owners : Vector.T<address>,
        credential_proofs: Vector.T<Proofs.CredentialProof>,
        credentials: Vector.T<Proofs.Credential>
    }

    resource DigestHolderProofs {
        digest_holders: Vector.T<Proofs.CredentialProof>
    }

    //--------------------------------
    // Methods
    //--------------------------------
    public createIssuerLoggedProof(_owners: Vector.T<address>){
        move_to_sender<LoggedProofs>(
            LoggedProofs {
                owners: move(_owners),
                credential_proofs : Vector.empty<Proofs.CredentialProof>(),
                credentials : Vector.empty<Proofs.Credential>()
            }
        );
        return ;
    }

    // sign credential under appropriate credentialproof
    // invoked by : owner
    // expected action
    // - sign the credential associated with bytearray
    // - check if quorums on credential has been reached
    // - move credential to appropriate credential proof
    // - compute digest of credential proof based on all included credential
    public signCredential(issuer: address, digest: bytearray) acquires LoggedProofs{
        let requester_logged_proofs: & Self.LoggedProofs;
        let success: bool;

        // 1. move the claimed credential proof to holder's wallet
        // Fetch claimed credential proof
        requester_logged_proofs = borrow_global<LoggedProofs>(copy(issuer));

        return;
    }

    // // register credential under appropriate credentialproof
    public registerCredential(credential: Proofs.Credential) acquires LoggedProofs{
        let requester_logged_proofs: &mut Self.LoggedProofs;
        let success: bool;

        // 1. move the claimed credential proof to holder's wallet
        // Fetch claimed credential proof
        requester_logged_proofs = borrow_global_mut<LoggedProofs>(get_txn_sender());
        success = Proofs.insertCredential(
            &mut copy(requester_logged_proofs).credential_proofs, 
            &copy(requester_logged_proofs).credential_proofs, 
            move(credential)
        );
        assert(copy(success), 42);
        return;
    }

    // called by issuer when registering CP
    // fails if it is not an issuer running this
    public registerCP(cp: Proofs.CredentialProof) acquires LoggedProofs{
        let requester_logged_proofs: &mut Self.LoggedProofs;
        requester_logged_proofs = borrow_global_mut<LoggedProofs>(get_txn_sender());
        Vector.push_back<Proofs.CredentialProof>(
            &mut copy(requester_logged_proofs).credential_proofs, 
            move(cp)
        );
        return;
    }

    // called by receipient to claimCP. Can only be claimed if a quorum of owners have signed
    // params : 
    // issuer : address of the issuing course
    public claimCP(issuer: address, digest: bytearray) acquires LoggedProofs{
        let cp_index: u64;
        let cp_exists: bool;
        let credential_proof: Proofs.CredentialProof;
        let requester_logged_proofs: &mut Self.LoggedProofs;

        // 1. move the claimed credential proof to holder's wallet
        // Fetch claimed credential proof
        requester_logged_proofs = borrow_global_mut<LoggedProofs>(get_txn_sender());
        cp_index, cp_exists = Proofs.getCredentialProofIndexByDigest(&copy(requester_logged_proofs).credential_proofs, &digest, true);
        
        // check that a credential proof exists
        assert(copy(cp_exists), 42);
        
        // remove credential proof from issuer resource
        credential_proof = Vector.remove_unstable<Proofs.CredentialProof>(&mut copy(requester_logged_proofs).credential_proofs, copy(cp_index));

        // move credential proof to holder account
        Proofs.moveCredentialsProofToAccount(move(credential_proof), get_txn_sender());

        return;
    }

    // owner sign CP
    public signCP(digest: bytearray, issuer:address){

        // let credential: &Proofs.Credential;
        // credential = Self.getCredentialByDigest(get_txn_sender(), copy(digest)); 
        // Proofs.signCredential()
        return;
    }


    // getCredentialByDigest(holder:address, digest:bytearray): &Proofs.Credential{
    //     let cp_index: u64;
    //     let cp_exists: bool;
    //     let credential: &mut Proofs.Credential;
    //     let credential_proof: &mut Proofs.CredentialProof;
    //     let requester_logged_proofs: &mut Self.LoggedProofs;

    //     requester_logged_proofs = borrow_global_mut<LoggedProofs>(copy(holder));
    //     cp_index, cp_exists = Proofs.getCredentialProofIndexByDigest(&copy(requester_logged_proofs).credential_proofs, &digest, false);

    //     // check that a credential proof exists
    //     assert(copy(cp_exists), 42);

    //     credential_proof = Vector.borrow_mut<Proofs.CredentialProof>(&mut copy(requester_logged_proofs).credential_proofs, copy(cp_index));

    //     return;
    // }
    
    // after a holder signs
    // saveToDigestHolderResource(){}

}

//! new-transaction
//! sender: bbchain
// The Issuer module is more like a ERC20 standard that has to be followed 
// to create a coin in the ethereum system but here it will be used for
// creating notary module and can be used by courses in the libra network.
module Issuer {
    import 0x0.LibraAccount;
    import 0x0.Vector;
    import 0x0.LibraSystem;
    import 0x0.AddressUtil;
    import {{bbchain}}.Proofs;
    import {{bbchain}}.EarmarkedProofs;

    //--------------------------------
    // Resources
    //--------------------------------
    resource IssuerResource{
        owners : Vector.T<address>,
        sub_issuers : Vector.T<address>,
        parent_issuer : address,
        holders : Vector.T<address>,
        digests : Vector.T<bytearray>,
        revoked_digests : Vector.T<bytearray>,
        nonce: u64, // counter for each issue/revoke operation because it modifies ledger state
        quorum : u64,
        required_credentials: u64,
    }

    //--------------------------------
    // Methods
    //--------------------------------
    public registerIssuer(_owners: Vector.T<address>, _parent_issuer: address, _quorum: u64, _required_credentials: u64) {
        // validate if sender already holds an issuer resource
        assert(!Self.hasIssuerResource(get_txn_sender()), 42);
        move_to_sender<IssuerResource>(
            Self.newIssuerResource(
                copy(_owners), 
                copy(_parent_issuer), 
                copy(_quorum), 
                copy(_required_credentials)
            )
        );
        EarmarkedProofs.createIssuerLoggedProof(copy(_owners));
        return;
    }

    // student use this to register register with Issuer
    public initHolder(_issuer: address) acquires IssuerResource{
        assert(!Self.hasIssuerResource(get_txn_sender()), 42); // shouldn't be a holder
        assert(!Proofs.hasCredentialAccount(get_txn_sender()), 42); // shouldn't hold a credential wallet
        // TODO : check that the issuer has issuer resource

        Self.addHolder(get_txn_sender(), copy(_issuer));
        Proofs.newCredentialAccount(move(_issuer), get_txn_sender());
        
        return;
    }

    // requested by sub issuer to register it under its parent issuer
    public registerSubIssuer(_owners: Vector.T<address>, parent_issuer: address,  _quorum: u64, _required_credentials: u64) acquires IssuerResource{
        let requester_account_ref: &mut Self.IssuerResource;
        assert(Self.hasIssuerResource(get_txn_sender()), 42); // only issuer can run this op.

        // update issuer resource and add new holder
        requester_account_ref = borrow_global_mut<IssuerResource>(copy(parent_issuer));
        Vector.push_back<address>(&mut copy(requester_account_ref).sub_issuers, get_txn_sender());

        Self.registerIssuer(copy(_owners), copy(parent_issuer),  copy(_quorum), copy(_required_credentials));
        return;
    }

    public hasIssuerResource(addr: address): bool {
        let issuerResourceExists: bool;
        issuerResourceExists = exists<IssuerResource>(move(addr));
        return move(issuerResourceExists);
    }

    //register holders credential proof in issuer logged proof
    public registerHolder(holder:address) acquires IssuerResource{
        let requester_account_ref: &Self.IssuerResource;
        let credential_proof: Proofs.CredentialProof;

        requester_account_ref = borrow_global<IssuerResource>(get_txn_sender());

        credential_proof = Proofs.newCredentialProof(
            get_txn_sender(), 
            copy(holder), 
            *&copy(requester_account_ref).quorum, 
            *&copy(requester_account_ref).owners, 
            *&copy(requester_account_ref).required_credentials
        );
        
        EarmarkedProofs.registerCP(move(credential_proof));

        return;
    }

    // register holders credential under appropriate credential proof
    public registerCredential(holder:address, digest: bytearray) acquires IssuerResource{
        let requester_account_ref: &Self.IssuerResource;
        let credential: Proofs.Credential;

        requester_account_ref = borrow_global<IssuerResource>(get_txn_sender());

        credential = Proofs.newCredential(
            copy(holder),
            copy(digest),
            *&copy(requester_account_ref).owners
        );
        
        EarmarkedProofs.registerCredential(move(credential));
        return;
    }

    // // assert that the transaction sender is a valid owner
    public canSign(issuer:address): bool acquires IssuerResource{
        let requester_account_ref: &Self.IssuerResource;
        let can_sign: bool;
        let addr: address;

        addr = get_txn_sender();

        requester_account_ref = borrow_global<IssuerResource>(copy(issuer));
        can_sign = Vector.contains<address>(&copy(requester_account_ref).owners, &addr);
        
        return copy(can_sign);
    }

    // public issueCredential(){

    // }

    // public revokeCredential(){

    // }

    // public verifyCredential(){

    // }

    newIssuerResource(_owners: Vector.T<address>, parent_issuer: address, _quorum: u64, _required_credentials: u64): Self.IssuerResource {
        return IssuerResource { 
            owners : move(_owners),
            sub_issuers : Vector.empty<address>(),
            parent_issuer : move(parent_issuer),
            holders : Vector.empty<address>(),
            digests : Vector.empty<bytearray>(),
            revoked_digests : Vector.empty<bytearray>(),
            nonce : 1,
            quorum : copy(_quorum),
            required_credentials: copy(_required_credentials),
        };
    }

    // adds holder to issuer resource
    addHolder(_holder: address, _issuer: address) acquires IssuerResource{
        let requester_account_ref: &mut Self.IssuerResource;
        assert(Self.hasIssuerResource(copy(_issuer)), 42); // verify issuer

        // update issuer resource and add new holder
        requester_account_ref = borrow_global_mut<IssuerResource>(copy(_issuer));
        Vector.push_back<address>(&mut copy(requester_account_ref).holders, copy(_holder));

        // if a issuer has some facts then assign them to holder
        // they wont be a certified fact but a proof of knowledge 
        // that issuer knows the holder
        
        return;
    }
}


// // Test that a university can register
// //! new-transaction
// //! sender: university
// import {{bbchain}}.Proofs;
// import {{bbchain}}.Issuer;
// import 0x0.Vector;
// main() {
//     let issuerResourceExists: bool;
//     // check if issuer resource exists
//     issuerResourceExists = Issuer.hasIssuerResource({{university}});
//     assert(move(issuerResourceExists) == false, 42);
//     return;
// }

// // Test that a university can register
// //! new-transaction
// //! sender: university
// import {{bbchain}}.Proofs;
// import {{bbchain}}.Issuer;
// import 0x0.Vector;
// main() {
//     let exists1: bool;
//     let sender: address;

//     // register issuer with no parent
//     Issuer.registerIssuer(Vector.empty<address>(), 0x00);
    
//     // check if issuer resource exists
//     sender = get_txn_sender();
//     exists1 = Issuer.hasIssuerResource(copy(sender));
//     assert(move(exists1), 42);
//     return;
// }

// // Test that a course can be registered
// //! new-transaction
// //! sender: mathcourse
// import {{bbchain}}.Issuer;
// import 0x0.Vector;
// import {{bbchain}}.Proofs;
// main() {
//     let exists1: bool;
//     let sender: address;
//     let ir: Issuer.IssuerResource;

//     let owners: Vector.T<address>;
//     owners = Vector.empty<address>();
//     Vector.push_back<address>(&mut owners, {{mathprofessor}});
//     Vector.push_back<address>(&mut owners, {{mathevaluator}});
    

//     // register issuer with no parent
//     Issuer.registerIssuer(move(owners), {{university}});
    
//     // check if issuer resource exists
//     sender = get_txn_sender();
//     exists1 = Issuer.hasIssuerResource(copy(sender));
//     assert(move(exists1), 42);

//     return;
// }

// // Test that a holder(student) can register in a university
// //! new-transaction
// //! sender: student1
// import {{bbchain}}.Issuer;
// import {{bbchain}}.Proofs;
// import 0x0.Vector;
// main() {
//     let exists1: bool;
//     // check if issuer resource exists
//     exists1 = Proofs.hasCredentialAccount(get_txn_sender());
//     assert(move(exists1) == false, 42);

//     //register
//     Issuer.initHolder({{university}});
//     // Issuer.registerHolder({{mathcourse}});
    
//     return;
// }