//! account: bbchain, 1000000
//! account: university, 1000000
//! account: mathcourse, 1000000
//! account: mathprofessor, 1000000
//! account: mathevaluator, 1000000
//! account: student1, 1000000

//! new-transaction
//! sender: bbchain
module Proofs {
    import 0x0.Vector;
    struct Credential{
        digest : bytearray,
        signed : bool,
        revoked : bool
    }

    resource CredentialProof{
        issuer: Vector.T<address>,
        owners : Vector.T<address>,
        sub_credential_proofs : Vector.T<address>, // exams
        signed_by : Vector.T<address>,
        valid : bool,
        revoked : bool,
        digest : bytearray,
        credentials: Vector.T<Self.Credential>,
    }

    resource RevocationProof {
        credentialProof: Self.CredentialProof,
        reason: bytearray,
        nonce: u64 // counter from issuer
    }

    // stored with holder
    resource CredentialAccount{
        wallet_issuer : address,
        holder : address,
        credential_proofs : Vector.T<Self.CredentialProof>   
    }

    // stored with issuer
    resource RevocationProofs{
        credential_proofs : Vector.T<Self.RevocationProof>   
    }
}


// module that allows issuer to mark a credential resource for recepients
//! new-transaction
//! sender: bbchain
module EarmarkedCredentialProof {
    import {{bbchain}}.Proofs;
    import 0x0.Vector;

    // A wrapper containing a Libra coin and the address of the recipient the
    // coin is earmarked for.
    resource LoggedProofs {
        credential_proofs: Vector.T<Proofs.CredentialProof>
    }

    public createIssuerResource(): Self.LoggedProofs {
        return LoggedProofs {
            credential_proofs : Vector.empty<Proofs.CredentialProof>()
        };
    }

    // called by issuer when issuing CP
    // fails if it is not an issuer running this
    public registerCP(cp: Proofs.CredentialProof) acquires LoggedProofs{
        let requester_logged_proofs: &mut Self.LoggedProofs;
        requester_logged_proofs = borrow_global_mut<LoggedProofs>(get_txn_sender());
        Vector.push_back<Proofs.CredentialProof>(
            &mut copy(requester_logged_proofs).credential_proofs, 
            move(cp)
        );
        return;
    }

    // called by receipient to claimCP. Can only be claimed if a quorum of owners have signed
    // params : 
    // issuer : address of the issuing course
    public claimCP(issuer: address, digest: bytearray){
        let cp_index: u64;
        let cp_exists: bool;
        let credential_proof: Proofs.CredentialProof;
        let requester_credential_account_ref: &mut Proofs.CredentialAccount;
        let requester_logged_proofs: &mut Self.LoggedProofs;

        // move the claimed credential proof to holder's wallet
        // cp_index, cp_exists = Self.getCredentialProofIndexByDigest(&copy(requester_logged_proofs).credential_proofs, &digest);
        
        // check that a credential proof exists
        // assert(copy(cp_exists), 42);
        
        // remove credential proof from issuer resource
        // credential_proof = Vector.remove_unstable<bytearray>(&mut copy(requester_logged_proofs).credential_proofs, copy(cp_index));

        // // // move credential proof to holder account
        // // requester_credential_account_ref = borrow_global_mut<Proofs.CredentialAccount>(get_txn_sender());
        // // Vector.push_back<Proofs.CredentialProof>(
        // //     &mut copy(requester_credential_account_ref).credential_proofs, 
        // //     move(credential_proof)
        // // );

        // add digest to issuer resource
        return;
    }

    getCredentialProofIndexByDigest(credential_proofs: &Vector.T<Proofs.CredentialProof>, digest: &bytearray): u64 * bool {
        // let len: u64;
        // let i: u64;
        // let credential_proof_ref: &Proofs.CredentialProof;

        // i = 0;
        // len = Vector.length<Proofs.CredentialProof>(copy(credential_proofs));

        // while (copy(i) < copy(len)) {
        //     credential_proof_ref = Vector.borrow<Proofs.CredentialProof>(copy(credential_proofs), copy(i));
            
        //     if (*copy(digest) == *&copy(credential_proof_ref).digest) {
        //         return copy(i), true;
        //     }
        //     i = move(i) + 1;
        // }

        return 0, false;
    }

}

//! new-transaction
//! sender: bbchain
// The Issuer module is more like a ERC20 standard that has to be followed 
// to create a coin in the ethereum system but here it will be used for
// creating notary module and can be used by courses in the libra network.
module Issuer {
    import 0x0.LibraAccount;
    import 0x0.Vector;
    import 0x0.LibraSystem;
    import 0x0.AddressUtil;
    
    //--------------------------------
    // Structs
    //--------------------------------
    // represents course work / test
    struct Fact{
        issuer: address,
        digest : bytearray,
        signed : bool,
        revoked : bool
    }

    //--------------------------------
    // Resources
    //--------------------------------
    resource IssuerResource{
        owners : Vector.T<address>,
        sub_issuers : Vector.T<address>,
        parent_issuer : address,
        holders : Vector.T<address>,
        digests : Vector.T<bytearray>,
        revoked_digests : Vector.T<bytearray>,
        nonce: u64, // counter for each issue/revoke operation because it modifies ledger state
    }

    struct CredentialProof{
        owners : Vector.T<address>,
        sub_credential_proofs : Vector.T<address>, // exams
        signed_by : Vector.T<address>,
        valid : bool,
        revoked : bool,
        digest : bytearray,
        facts: Vector.T<Self.Fact>,
    }

    resource RevocationProof {
        credentialProof: Self.CredentialProof,
        reason: bytearray,
        nonce: u64 // counter from issuer
    }

    // stored with holder
    resource CredentialAccount{
        wallet_issuer : address,
        holder : address,
        credential_proofs : Vector.T<Self.CredentialProof>   
    }

    // stored with issuer
    resource RevocationProofs{
        credential_proofs : Vector.T<Self.RevocationProof>   
    }


    //--------------------------------
    // Methods
    //--------------------------------
    public registerIssuer(_owners: Vector.T<address>, parent_issuer: address) {
        // validate if sender already holds an issuer resource
        assert(!Self.hasIssuerResource(get_txn_sender()), 42);
        move_to_sender<IssuerResource>(
            Self.newIssueResource(copy(_owners), copy(parent_issuer))
        );
        return;
    }

    // student use this to register register with Issuer
    public initHolder(_issuer: address) acquires IssuerResource{
        assert(!Self.hasIssuerResource(get_txn_sender()), 42); // shouldn't be a holder
        assert(!Self.hasCredentialAccount(get_txn_sender()), 42); // shouldn't hold a credential wallet
        // TODO : check that the issuer has issuer resource

        Self.addHolder(get_txn_sender(), copy(_issuer));
        
        move_to_sender<CredentialAccount>(
            Self.newCredentialAccount(move(_issuer), get_txn_sender())
        );
        return;
    }

    public hasCredentialAccount(addr: address): bool {
        let has: bool;
        has = exists<CredentialAccount>(move(addr));
        return move(has);
    }

    public hasIssuerResource(addr: address): bool {
        let issuerResourceExists: bool;
        issuerResourceExists = exists<IssuerResource>(move(addr));
        return move(issuerResourceExists);
    }

    // requested by sub issuer to register it under its parent issuer
    public registerSubIssuer(_owners: Vector.T<address>, parent_issuer: address) acquires IssuerResource{
        let requester_account_ref: &mut Self.IssuerResource;
        assert(Self.hasIssuerResource(get_txn_sender()), 42); // only issuer can run this op.

        // update issuer resource and add new holder
        requester_account_ref = borrow_global_mut<IssuerResource>(copy(parent_issuer));
        Vector.push_back<address>(&mut copy(requester_account_ref).sub_issuers, get_txn_sender());

        Self.registerIssuer(copy(_owners), copy(parent_issuer));
        return;
    }

    public initFact(): Self.Fact {
        return Fact{
            issuer: get_txn_sender(),
            digest : h"",
            signed : false,
            revoked : false
        };
    }

    // adds holder to issuer resource
    addHolder(_holder: address, _issuer: address) acquires IssuerResource{
        let requester_account_ref: &mut Self.IssuerResource;
        assert(Self.hasIssuerResource(copy(_issuer)), 42); // verify issuer

        // update issuer resource and add new holder
        requester_account_ref = borrow_global_mut<IssuerResource>(copy(_issuer));
        Vector.push_back<address>(&mut copy(requester_account_ref).holders, copy(_holder));

        // if a issuer has some facts then assign them to holder
        // they wont be a certified fact but a proof of knowledge 
        // that issuer knows the holder
        
        return;
    }

    newCredentialAccount(_issuer: address, _holder: address): Self.CredentialAccount {
        return  CredentialAccount {
            wallet_issuer : move(_issuer),
            holder : move(_holder),
            credential_proofs : Vector.empty<Self.CredentialProof>()
        };
    }

    newIssueResource(_owners: Vector.T<address>, parent_issuer: address): Self.IssuerResource {
        return IssuerResource { 
            owners : move(_owners),
            sub_issuers : Vector.empty<address>(),
            parent_issuer: move(parent_issuer),
            holders : Vector.empty<address>(),
            digests : Vector.empty<bytearray>(),
            revoked_digests : Vector.empty<bytearray>(),
            nonce : 1
        };
    }
}


// // Test that a university can register
// //! new-transaction
// //! sender: university
// import {{bbchain}}.Issuer;
// import 0x0.Vector;
// main() {
//     let issuerResourceExists: bool;
//     // check if issuer resource exists
//     issuerResourceExists = Issuer.hasIssuerResource({{university}});
//     assert(move(issuerResourceExists) == false, 42);
//     return;
// }

// // Test that a university can register
// //! new-transaction
// //! sender: university
// import {{bbchain}}.Issuer;
// import 0x0.Vector;
// main() {
//     let exists1: bool;
//     let sender: address;

//     // register issuer with no parent
//     Issuer.registerIssuer(Vector.empty<address>(), 0x00);
    
//     // check if issuer resource exists
//     sender = get_txn_sender();
//     exists1 = Issuer.hasIssuerResource(copy(sender));
//     assert(move(exists1), 42);
//     return;
// }

// // Test that a course can be registered
// //! new-transaction
// //! sender: mathcourse
// import {{bbchain}}.Issuer;
// import 0x0.Vector;
// main() {
//     let exists1: bool;
//     let sender: address;
//     let ir: Issuer.IssuerResource;

//     let owners: Vector.T<address>;
//     owners = Vector.empty<address>();
//     Vector.push_back<address>(&mut owners, {{mathprofessor}});
//     Vector.push_back<address>(&mut owners, {{mathevaluator}});
    

//     // register issuer with no parent
//     Issuer.registerIssuer(move(owners), {{university}});
    
//     // check if issuer resource exists
//     sender = get_txn_sender();
//     exists1 = Issuer.hasIssuerResource(copy(sender));
//     assert(move(exists1), 42);

//     return;
// }

// // Test that a holder(student) can register in a university
// //! new-transaction
// //! sender: student1
// import {{bbchain}}.Issuer;
// import 0x0.Vector;
// main() {
//     let exists1: bool;
//     // check if issuer resource exists
//     exists1 = Issuer.hasCredentialAccount(get_txn_sender());
//     assert(move(exists1) == false, 42);

//     //register
//     Issuer.initHolder({{university}});
//     Issuer.registerHolder({{mathcourse}});
    
//     return;
// }