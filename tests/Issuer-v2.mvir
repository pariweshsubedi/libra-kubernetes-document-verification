//! account: bbchain, 1000000
//! account: university, 1000000
//! account: mathcourse, 1000000
//! account: mathprofessor, 1000000
//! account: mathevaluator, 1000000
//! account: student1, 1000000

//! new-transaction
//! sender: bbchain
module Proofs {
    import 0x0.Vector;
    struct Fact{
        issuer: address,
        digest : bytearray,
        signed : bool,
        revoked : bool
    }

    resource CredentialProof{
        owners : Vector.T<address>,
        sub_credential_proofs : Vector.T<address>, // exams
        signed_by : Vector.T<address>,
        valid : bool,
        revoked : bool,
        digest : bytearray,
        facts: Vector.T<Self.Fact>,
    }

    resource RevocationProof {
        credentialProof: Self.CredentialProof,
        reason: bytearray,
        nonce: u64 // counter from issuer
    }

    // stored with holder
    resource CredentialAccount{
        wallet_issuer : address,
        holder : address,
        credential_proofs : Vector.T<Self.CredentialProof>   
    }

    // stored with issuer
    resource RevocationProofs{
        credential_proofs : Vector.T<Self.RevocationProof>   
    }
}



//! new-transaction
//! sender: bbchain
module EarmarkedCredentialProof {
  import {{bbchain}}.Proofs;

  // A wrapper containing a Libra coin and the address of the recipient the
  // coin is earmarked for.
  resource T {
    credential_proof: Proofs.CredentialProof,
    recipient: address
  }

  // Create a new earmarked coin with the given `recipient`.
  // Publish the coin under the transaction sender's account address.
  public create(credential_proof: Proofs.CredentialProof, recipient: address) {
    let t: Self.T;

    // Construct or "pack" a new resource of type T. Only procedures of the
    // `EarmarkedLibraCoin` module can create an `EarmarkedLibraCoin.T`.
    t = T {
      credential_proof: move(credential_proof),
      recipient: move(recipient),
    };

    // Publish the earmarked coin under the transaction sender's account
    // address. Each account can contain at most one resource of a given type;
    // this call will fail if the sender already has a resource of this type.
    move_to_sender<T>(move(t));
    return;
  }

  // Allow the transaction sender to claim a coin that was earmarked for her.
  public claim_for_recipient(earmarked_cp_address: address): Self.T acquires T {
    let t: Self.T;
    let t_ref: &Self.T;
    let sender: address;

    // Remove the earmarked coin resource published under `earmarked_cp_address`.
    // If there is no resource of type T published under the address, this will fail.
    t = move_from<T>(move(earmarked_cp_address));

    t_ref = &t;
    // This is a builtin that returns the address of the transaction sender.
    sender = get_txn_sender();
    // Ensure that the transaction sender is the recipient. If this assertion
    // fails, the transaction will fail and none of its effects (e.g.,
    // removing the earmarked coin) will be committed.  99 is an error code
    // that will be emitted in the transaction output if the assertion fails.
    assert(*(&move(t_ref).recipient) == move(sender), 99);

    return move(t);
  }

  // Extract the Libra coin from its wrapper and return it to the caller.
  public unwrap(t: Self.T): Proofs.CredentialProof {
    let cp: Proofs.CredentialProof;
    let recipient: address;

    // This "unpacks" a resource type by destroying the outer resource, but
    // returning its contents. Only the module that declares a resource type
    // can unpack it.
    T { cp, recipient } = move(t);
    return move(cp);
  }

}

//! new-transaction
//! sender: bbchain
// The Issuer module is more like a ERC20 standard that has to be followed 
// to create a coin in the ethereum system but here it will be used for
// creating notary module and can be used by courses in the libra network.
module Issuer {
    import 0x0.LibraAccount;
    import 0x0.Vector;
    import 0x0.LibraSystem;
    import 0x0.AddressUtil;
    
    //--------------------------------
    // Structs
    //--------------------------------
    // represents course work / test
    struct Fact{
        issuer: address,
        digest : bytearray,
        signed : bool,
        revoked : bool
    }

    //--------------------------------
    // Resources
    //--------------------------------
    resource IssuerResource{
        owners : Vector.T<address>,
        sub_issuers : Vector.T<address>,
        parent_issuer : address,
        holders : Vector.T<address>,
        digests : Vector.T<bytearray>,
        revoked_digests : Vector.T<bytearray>,
        nonce: u64, // counter for each issue/revoke operation because it modifies ledger state
    }

    struct CredentialProof{
        owners : Vector.T<address>,
        sub_credential_proofs : Vector.T<address>, // exams
        signed_by : Vector.T<address>,
        valid : bool,
        revoked : bool,
        digest : bytearray,
        facts: Vector.T<Self.Fact>,
    }

    resource RevocationProof {
        credentialProof: Self.CredentialProof,
        reason: bytearray,
        nonce: u64 // counter from issuer
    }

    // stored with holder
    resource CredentialAccount{
        wallet_issuer : address,
        holder : address,
        credential_proofs : Vector.T<Self.CredentialProof>   
    }

    // stored with issuer
    resource RevocationProofs{
        credential_proofs : Vector.T<Self.RevocationProof>   
    }


    //--------------------------------
    // Methods
    //--------------------------------
    public registerIssuer(_owners: Vector.T<address>, parent_issuer: address) {
        // validate if sender already holds an issuer resource
        assert(!Self.hasIssuerResource(get_txn_sender()), 42);
        move_to_sender<IssuerResource>(
            Self.newIssueResource(copy(_owners), copy(parent_issuer))
        );
        return;
    }

    // student use this to register register with Issuer
    public registerHolder(_issuer: address) acquires IssuerResource{
        assert(!Self.hasIssuerResource(get_txn_sender()), 42); // shouldn't be a holder
        assert(!Self.hasCredentialAccount(get_txn_sender()), 42); // shouldn't hold a credential wallet
        // TODO : check that the issuer has issuer resource

        Self.addHolder(get_txn_sender(), copy(_issuer));
        
        move_to_sender<CredentialAccount>(
            Self.newCredentialAccount(move(_issuer), get_txn_sender())
        );
        return;
    }

    public hasCredentialAccount(addr: address): bool {
        let has: bool;
        has = exists<CredentialAccount>(move(addr));
        return move(has);
    }

    public hasIssuerResource(addr: address): bool {
        let issuerResourceExists: bool;
        issuerResourceExists = exists<IssuerResource>(move(addr));
        return move(issuerResourceExists);
    }

    // requested by sub issuer
    public registerSubIssuer(_owners: Vector.T<address>, parent_issuer: address) acquires IssuerResource{
        let requester_account_ref: &mut Self.IssuerResource;
        assert(Self.hasIssuerResource(get_txn_sender()), 42); // only issuer can run this op.

        // update issuer resource and add new holder
        requester_account_ref = borrow_global_mut<IssuerResource>(copy(parent_issuer));
        Vector.push_back<address>(&mut copy(requester_account_ref).sub_issuers, get_txn_sender());

        Self.registerIssuer(copy(_owners), copy(parent_issuer));
        return;
    }

    public initFact(): Self.Fact {
        return Fact{
            issuer: get_txn_sender(),
            digest : h"",
            signed : false,
            revoked : false
        };
    }

    // adds holder to issuer resource
    addHolder(_holder: address, _issuer: address) acquires IssuerResource{
        let requester_account_ref: &mut Self.IssuerResource;
        assert(Self.hasIssuerResource(copy(_issuer)), 42); // verify issuer

        // update issuer resource and add new holder
        requester_account_ref = borrow_global_mut<IssuerResource>(copy(_issuer));
        Vector.push_back<address>(&mut copy(requester_account_ref).holders, copy(_holder));

        // if a issuer has some facts then assign them to holder
        // they wont be a certified fact but a proof of knowledge 
        // that issuer knows the holder
        
        return;
    }

    newCredentialAccount(_issuer: address, _holder: address): Self.CredentialAccount {
        return  CredentialAccount {
            wallet_issuer : move(_issuer),
            holder : move(_holder),
            credential_proofs : Vector.empty<Self.CredentialProof>()
        };
    }

    newIssueResource(_owners: Vector.T<address>, parent_issuer: address): Self.IssuerResource {
        return IssuerResource { 
            owners : move(_owners),
            sub_issuers : Vector.empty<address>(),
            parent_issuer: move(parent_issuer),
            holders : Vector.empty<address>(),
            digests : Vector.empty<bytearray>(),
            revoked_digests : Vector.empty<bytearray>(),
            nonce : 1
        };
    }
}


// Test that a university can register
//! new-transaction
//! sender: university
import {{bbchain}}.Issuer;
import 0x0.Vector;
main() {
    let issuerResourceExists: bool;
    // check if issuer resource exists
    issuerResourceExists = Issuer.hasIssuerResource({{university}});
    assert(move(issuerResourceExists) == false, 42);
    return;
}

// Test that a university can register
//! new-transaction
//! sender: university
import {{bbchain}}.Issuer;
import 0x0.Vector;
main() {
    let exists1: bool;
    let sender: address;

    // register issuer with no parent
    Issuer.registerIssuer(Vector.empty<address>(), 0x00);
    
    // check if issuer resource exists
    sender = get_txn_sender();
    exists1 = Issuer.hasIssuerResource(copy(sender));
    assert(move(exists1), 42);
    return;
}

// Test that a course can be registered
//! new-transaction
//! sender: mathcourse
import {{bbchain}}.Issuer;
import 0x0.Vector;
main() {
    let exists1: bool;
    let sender: address;
    let ir: Issuer.IssuerResource;

    let owners: Vector.T<address>;
    owners = Vector.empty<address>();
    Vector.push_back<address>(&mut owners, {{mathprofessor}});
    Vector.push_back<address>(&mut owners, {{mathevaluator}});
    

    // register issuer with no parent
    Issuer.registerIssuer(move(owners), {{university}});
    
    // check if issuer resource exists
    sender = get_txn_sender();
    exists1 = Issuer.hasIssuerResource(copy(sender));
    assert(move(exists1), 42);

    return;
}

// Test that a holder(student) can register in a university
//! new-transaction
//! sender: student1
import {{bbchain}}.Issuer;
import 0x0.Vector;
main() {
    let exists1: bool;
    // check if issuer resource exists
    exists1 = Issuer.hasCredentialAccount(get_txn_sender());
    assert(move(exists1) == false, 42);

    //register
    Issuer.registerHolder({{university}});
    
    return;
}