//! account: bbchain, 1000000
//! account: university, 1000000
//! account: mathcourse, 1000000
//! account: mathprofessor, 1000000
//! account: mathevaluator, 1000000
//! account: student1, 1000000

//! new-transaction
//! sender: bbchain
// The Issuer module is more like a ERC20 standard that has to be followed 
// to create a coin in the ethereum system but here it will be used for
// creating notary module and can be used by courses in the libra network.
module Issuer {
    import 0x0.LibraAccount;
    import 0x0.Vector;
    import 0x0.LibraSystem;
    import 0x0.AddressUtil;

    //--------------------------------
    // Resources
    //--------------------------------
    resource IssuerResource{
        owners : Vector.T<address>,
        sub_issuers : Vector.T<address>,
        holders : Vector.T<address>,
        digests : Vector.T<bytearray>,
        revoked_digests : Vector.T<bytearray>,
        nonce: u64 // counter for each issue/revoke operation because it modifies ledger state
    }

    resource CredentialProof{
        issuer : address,
        owners : Vector.T<address>,
        sub_credential_proofs : Vector.T<address>, // exams
        signed_by : Vector.T<address>,
        valid : bool,
        revoked : bool,
        digest : bytearray,
    }

    resource RevocationProof {
        credentialProof: Self.CredentialProof,
        reason: bytearray,
        nonce: u64 // counter from issuer
    }

    // only a part of holder's resource
    resource CredentialProofs{
        credential_proofs : Vector.T<Self.CredentialProof>   
    }

    // only a part of issuer's resource
    resource RevocationProofs{
        credential_proofs : Vector.T<Self.CredentialProof>   
    }


    //--------------------------------
    // Methods
    //--------------------------------
    public registerIssuer(owners: Vector.T<address>) {
        // TODO : validate if it already holds an issuer resource
        assert(!Self.isIssuer(get_txn_sender()), 42)
        move_to_sender<IssuerResource>(Self.newIssueResource(move(owners)));
        return;
    }

    public isIssuer(addr: address): bool {
        let issuerResourceExists: bool;
        issuerResourceExists = exists<IssuerResource>(move(addr));
        return move(issuerResourceExists);
    }

    newIssueResource(_owners: Vector.T<address>): Self.IssuerResource {
        return IssuerResource { 
            owners : move(_owners),
            sub_issuers : Vector.empty<address>(),
            holders : Vector.empty<address>(),
            digests : Vector.empty<bytearray>(),
            revoked_digests : Vector.empty<bytearray>(),
            nonce: 1 
        };
    }
}


// Test that a university can register
//! new-transaction
//! sender: university

import {{bbchain}}.Issuer;
import 0x0.Vector;
main() {
    let issuerResourceExists: bool;
    // check if issuer resource exists
    issuerResourceExists = Issuer.isIssuer({{university}});
    assert(move(issuerResourceExists) == false, 42);
    return;
}

// Test that a university can register
//! new-transaction
//! sender: university
import {{bbchain}}.Issuer;
import 0x0.Vector;
main() {
    let exists1: bool;
    let sender: address;
    // register course
    Issuer.registerIssuer(Vector.empty<address>());
    
    // check if issuer resource exists
    sender = get_txn_sender();
    exists1 = Issuer.isIssuer(copy(sender));
    assert(move(exists1), 42);
    return;
}